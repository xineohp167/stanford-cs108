/* Demonstrates using individual lock objects with the synchronized(lock) {...} form instead of synchronizing methods -- allows finer grain in the locking.*/class MultiSynch {	// one lock for the fruits	private int apple, banana;	private Object fruitLock;		// one lock for the nums	private int[] nums;	private int numLen;	private Object numLock;		public MultiSynch() {		apple = 0;		banana = 0;		// allocate an object just to use it as a lock		// (could use a string or some other object just as well)		fruitLock = new Object();				nums = new int[100];		numLen = 0;		numLock = new Object();	}		public void addFruit() {		synchronized(fruitLock) {			apple++;			banana++;		}	}		public int getFruit() {		synchronized(fruitLock) {			return(apple+banana);		}	}		public void pushNum(int num) {		synchronized(numLock) {			nums[numLen] = num;			numLen++;		}	}	// Suppose we pop and return num, but if the num is negative return	// its absolute value -- demonstrates holding the lock for the minimum time.	public int popNum() {		int result;		synchronized(numLock) {			result = nums[numLen-1];			numLen--;		}		// do computation not holding the lock if possible		if (result<0) result = -1 * result;		return(result);	}		public void both() {		synchronized(fruitLock) {			synchronized(numLock) {				// some scary operation that uses both fruit and nums				// note: acquire locks in the same order everwhere to avoid				// deadlock.			}		}	}}